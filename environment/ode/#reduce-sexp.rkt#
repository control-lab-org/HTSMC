#lang racket
(provide reduce-sexp)


(define (one? something)
  (equal? something 1))

(define (two? something)
  (equal? something 2))

(define (three? something)
  (equal? something 3))


(define (replace-syms quo)
  (cond
    [(equal? quo '-) -]
    [(equal? quo '+) +]
    [(equal? quo '*) *]
    [(equal? quo '/) /]
    [(equal? quo 'tanh) tanh]
    ))

(define (parse-unary-fix sexp)
  (let* ([op (first sexp)]
         [arg0 (reduce-exp (second sexp))]
         )
    (if (number? arg0)
        ((replace-syms op) arg0)
        (list op (list  arg0))))) 
    
(define (parse-binary-fix sexp)
  (let* ([op (first sexp)]
         [arg0 (reduce-exp (second sexp))]
         [arg1 (reduce-exp (third sexp))])
    (if (and (number? arg0) (number? arg1))
        ((replace-syms op) arg0 arg1)
        (list op arg0  arg1)
        )))

(define (parse-fix sexp)
  (let ([len (length sexp)])
    (cond
      [(zero? len) 'zero]
      [(one? len) (check-arg sexp)]
      [(two? len)  (parse-unary-fix sexp)]
      [(three? len) (parse-binary-fix sexp) ]
      [else 'error])
      ))

(define (reduce-sexp sexp)
  (cond
    [(list? sexp)  (parse-fix sexp)]
    [(number? sexp) (round-float sexp)]
    [else sexp]))
